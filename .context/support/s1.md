# WebSocket Real-Time Sync Bug Analysis & Fix Plan

## Problem Statement
When viewing the same list on two devices (phone + emulator), adding an item on one device does not appear in real-time on the other device. Users must leave the list and reopen it to see changes, indicating the app is behaving like a purely RESTful application rather than utilizing WebSocket real-time updates.

## Root Cause Analysis

### What's Currently Happening

#### Backend WebSocket Broadcasting ‚úÖ
The backend **IS** broadcasting WebSocket messages when items are created:
- [item_service.py:25-40](backend/services/item_service.py#L25-L40) - Broadcasts `item_added` event with item data
- [item_service.py:94-110](backend/services/item_service.py#L94-L110) - Broadcasts `item_updated` event when toggling items
- Event type: `"item_added"` with full item details in payload

#### Frontend WebSocket Connection ‚úÖ
The client **IS** connecting to WebSocket and receiving messages:
- [list_websocket_service.dart:66-85](client/listonit/lib/features/lists/services/list_websocket_service.dart#L66-L85) - Receives and processes messages
- [sync_provider.dart:54-79](client/listonit/lib/features/lists/providers/sync_provider.dart#L54-L79) - Handles incoming sync messages

#### The Bug üêõ
**The sync_provider is receiving `item_added`/`item_updated`/`item_deleted` messages but NOT processing them!**

Looking at [sync_provider.dart:73-77](client/listonit/lib/features/lists/providers/sync_provider.dart#L73-L77):

```dart
case 'item_created':
case 'item_updated':
case 'item_deleted':
  // These are handled by the items provider
  break;
```

**The comment says "handled by the items provider" but there's NO code actually forwarding these messages to the items provider!**

The items provider ([items_provider.dart](client/listonit/lib/features/items/providers/items_provider.dart)) has NO WebSocket listener setup. It only has:
- `applyReorderFromServer()` at line 543 (for reorder events only)
- No methods to handle `item_added`, `item_updated`, or `item_deleted` events

### Why Reordering Works But Item Creation Doesn't

Reordering DOES work because:
1. [list_detail_screen.dart:90-108](client/listonit/lib/features/lists/presentation/list_detail_screen.dart#L90-L108) explicitly listens for `items_reordered` events
2. Calls `itemsNotifier.applyReorderFromServer()` which exists in items_provider.dart

Item creation DOESN'T work because:
1. No screen is listening for `item_added` events
2. The items provider has no methods to handle these events
3. The sync_provider ignores these events entirely

## Fix Strategy

### Backend Message Type Mismatch ‚ö†Ô∏è
The backend sends `"item_added"` but the frontend expects `"item_created"`. This needs alignment.

**Backend broadcasts:**
- `"item_added"` - when creating items
- `"item_updated"` - when toggling/updating items
- No `"item_deleted"` event currently

**Frontend expects:**
- `"item_created"`
- `"item_updated"`
- `"item_deleted"`

### Solution Options

#### Option A: Fix Frontend to Match Backend (Recommended)
**Pros:**
- Less risky - only changes client code
- Backend is already working correctly
- Smaller change surface area

**Cons:**
- Frontend event names less semantic

**Changes needed:**
1. Update [sync_provider.dart:73-77](client/listonit/lib/features/lists/providers/sync_provider.dart#L73-L77) to handle `item_added`, `item_updated`, `item_deleted`
2. Add methods to [items_provider.dart](client/listonit/lib/features/items/providers/items_provider.dart):
   - `addItemFromServer(Item item)` - adds item to state without API call
   - `updateItemFromServer(Item item)` - updates item in state
   - `deleteItemFromServer(String itemId)` - removes item from state
3. Have sync_provider call these methods when messages arrive
4. Filter out messages where `user_id` matches current user (avoid double-adds from optimistic updates)

#### Option B: Fix Backend to Match Frontend
**Pros:**
- More semantic event names (`item_created` vs `item_added`)

**Cons:**
- Changes backend which is already broadcasting correctly
- Requires backend redeployment
- More risky if other clients depend on current event names

**Changes needed:**
1. Update [item_service.py:32](backend/services/item_service.py#L32) from `"item_added"` to `"item_created"`
2. Add `item_deleted` broadcasts to delete operations
3. Then follow same frontend changes as Option A

## Recommended Implementation Plan

### Phase 1: Add Item Sync Methods to Items Provider
**File:** [items_provider.dart](client/listonit/lib/features/items/providers/items_provider.dart)

Add these methods to `ItemsNotifier` class:

```dart
/// Add item received from WebSocket (other user's action)
void addItemFromServer(Map<String, dynamic> itemData) {
  try {
    final item = Item.fromJson(itemData);

    // Check if item already exists (avoid duplicates)
    if (state.items.any((i) => i.id == item.id)) {
      return;
    }

    state = state.copyWith(
      items: [...state.items, item],
    );
  } catch (e) {
    // Log error but don't crash
    debugPrint('Failed to add item from server: $e');
  }
}

/// Update item received from WebSocket (other user's action)
void updateItemFromServer(Map<String, dynamic> itemData) {
  try {
    final updatedItem = Item.fromJson(itemData);

    final itemIndex = state.items.indexWhere((i) => i.id == updatedItem.id);
    if (itemIndex == -1) {
      return; // Item not found, ignore
    }

    state = state.copyWith(
      items: state.items.map((i) =>
        i.id == updatedItem.id ? updatedItem : i
      ).toList(),
    );
  } catch (e) {
    debugPrint('Failed to update item from server: $e');
  }
}

/// Delete item received from WebSocket (other user's action)
void deleteItemFromServer(String itemId) {
  state = state.copyWith(
    items: state.items.where((i) => i.id != itemId).toList(),
  );
}
```

### Phase 2: Update Sync Provider to Handle Item Events
**File:** [sync_provider.dart](client/listonit/lib/features/lists/providers/sync_provider.dart)

Problem: `SyncNotifier` doesn't have access to `ref` to get the items provider!

**Solution:** We need to handle this in the screen where we have `ref` access, similar to how reordering works.

Update [list_detail_screen.dart:94-108](client/listonit/lib/features/lists/presentation/list_detail_screen.dart#L94-L108):

```dart
void _handleSyncMessage(SyncMessage message) {
  final itemsNotifier = ref.read(itemsProvider(widget.list.id).notifier);

  switch (message.type) {
    case 'item_added': // Backend sends 'item_added'
      final itemData = message.data['item'] as Map<String, dynamic>?;
      final userId = message.data['user_id'] as String?;

      // Don't process our own messages (optimistic updates already applied)
      if (userId != null && userId != currentUserId) {
        if (itemData != null) {
          itemsNotifier.addItemFromServer(itemData);
        }
      }
      break;

    case 'item_updated':
      final itemData = message.data['item'] as Map<String, dynamic>?;
      final userId = message.data['user_id'] as String?;

      if (userId != null && userId != currentUserId) {
        if (itemData != null) {
          itemsNotifier.updateItemFromServer(itemData);
        }
      }
      break;

    case 'item_deleted':
      final itemId = message.data['item_id'] as String?;
      final userId = message.data['user_id'] as String?;

      if (userId != null && userId != currentUserId) {
        if (itemId != null) {
          itemsNotifier.deleteItemFromServer(itemId);
        }
      }
      break;

    case 'items_reordered':
      final items = message.data['items'] as List?;
      if (items != null) {
        final reorderedData = items
            .map((item) => {
              'id': item['id'] as String,
              'sort_index': item['sort_index'] as int,
            })
            .toList();
        itemsNotifier.applyReorderFromServer(reorderedData);
      }
      break;
  }
}
```

**Challenge:** We need access to current user ID. Options:
1. Get from auth provider: `ref.read(authProvider).user?.id`
2. Get from message metadata (if backend includes it)
3. Store in sync state when connecting

### Phase 3: Add Missing Backend Broadcasts
**File:** [item_service.py](backend/services/item_service.py)

1. **Add broadcast to `update_item()`** at line 74-82 (currently missing)
2. **Add broadcast to `delete_item()`** at line 112-117 (currently missing)
3. **Add broadcast to `create_items_batch()`** at line 43-58 (currently missing)
4. **Add broadcast to batch operations** (batch_check, batch_delete, clear_checked)

Example for delete_item:

```python
def delete_item(self, list_id: str, item_id: str, user_id: str) -> None:
    self._verify_list_access(list_id, user_id)
    item = self._get_item_or_404(item_id, list_id)
    self.repository.delete(item)

    # Broadcast to WebSocket clients
    import asyncio
    try:
        asyncio.create_task(
            manager.broadcast(
                list_id,
                {
                    "type": "item_deleted",
                    "item_id": item_id,
                    "user_id": user_id,
                },
            )
        )
    except Exception:
        pass
```

### Phase 4: Testing Plan

1. **Test item creation:**
   - Open same list on 2 devices
   - Add item on device A
   - Verify item appears immediately on device B
   - Verify no duplicate items appear

2. **Test item toggle:**
   - Check/uncheck item on device A
   - Verify state updates on device B

3. **Test item deletion:**
   - Delete item on device A
   - Verify item disappears on device B

4. **Test optimistic updates:**
   - Verify own changes still feel instant (optimistic updates not broken)
   - Verify no duplicate items from receiving own WebSocket messages

5. **Test offline scenarios:**
   - Disconnect device B
   - Make changes on device A
   - Reconnect device B
   - Verify state eventually consistent

6. **Test batch operations:**
   - Batch add items
   - Batch check/uncheck
   - Clear checked items
   - Verify all broadcast correctly

## Key Files Reference

### Frontend
- [list_websocket_service.dart](client/listonit/lib/features/lists/services/list_websocket_service.dart) - WebSocket connection management
- [sync_provider.dart](client/listonit/lib/features/lists/providers/sync_provider.dart) - Sync state management
- [items_provider.dart](client/listonit/lib/features/items/providers/items_provider.dart) - Items state management ‚ö†Ô∏è NEEDS UPDATE
- [list_detail_screen.dart](client/listonit/lib/features/lists/presentation/list_detail_screen.dart) - UI screen with sync listeners ‚ö†Ô∏è NEEDS UPDATE

### Backend
- [item_service.py](backend/services/item_service.py) - Item operations with WebSocket broadcasts ‚ö†Ô∏è MISSING BROADCASTS
- [websocket_manager.py](backend/websocket_manager.py) - WebSocket connection manager ‚úÖ
- [ws.py](backend/api/v1/endpoints/ws.py) - WebSocket endpoint ‚úÖ

## Additional Notes

### Current Working Features
- ‚úÖ WebSocket connection establishment
- ‚úÖ User presence (join/leave events)
- ‚úÖ Typing indicators
- ‚úÖ Items reordering sync
- ‚úÖ Backend broadcasts for create/toggle

### Broken Features
- ‚ùå Item creation sync
- ‚ùå Item update sync
- ‚ùå Item deletion sync
- ‚ùå Batch operations sync
- ‚ùå Clear checked items sync

### Edge Cases to Consider
1. **Race conditions:** User A and B create item simultaneously
2. **Conflict resolution:** User A and B edit same item
3. **Reconnection:** Messages missed during disconnect
4. **Message ordering:** Out-of-order delivery
5. **Optimistic update conflicts:** Own action arrives via WebSocket

### Future Enhancements
1. **Message deduplication:** Track message IDs to prevent duplicates
2. **Conflict resolution:** Last-write-wins or CRDT-based
3. **Offline queue replay:** Sync queued actions on reconnect
4. **Delta updates:** Only send changed fields, not full items
5. **Batch broadcasts:** Combine multiple rapid changes into single message
